<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Shortest Route</title>
    <link rel="stylesheet" href="assets/css/style.css">
  </head>
  <body>
    <div class="component--layout">
      <header class="layout__header">
      </header>
      <main class="layout__main">
        <div class="component--maps">
          <div class="maps__items">
            <div class="maps__item">
              <div class="component--canvas">
                <div class="canvas__viewport">
                </div>
              </div>
            </div>
            <div class="maps__item">
              <div class="component--canvas">
                <div class="canvas__viewport">
                </div>
              </div>
            </div>
            <div class="maps__item">
              <div class="component--canvas">
                <div class="canvas__viewport">
                </div>
              </div>
            </div>
          </div>
        </div>
      </main>
      <footer class="layout__footer">
      </footer>
    </div>
    <script>
      const performanceSteps = [];
      performanceSteps[performanceSteps.length] = performance.now();
    </script>
    <script src="assets/js/EKF_Output4.js"></script>
    <script src="assets/js/EKF_Output5.js"></script>
    <script src="assets/js/EKF_Output6.js"></script>
    <script>
      const calcHypotenuse = (firstSide, secondSide) => Math.sqrt(Math.pow(firstSide, 2) + Math.pow(secondSide, 2));
      const calcTangent = (opposite, adjacent) => (opposite / adjacent);
      const radiansToDegrees = radians => (radians * (180/Math.PI));
    </script>
    <script src="assets/js/canvas.js"></script>
    <script src="assets/js/graph.js"></script>
    <script>
      function generateCanvas(type, element, map) {
        const props = {};
        props.element = element;
        props.theme = type;
        props.points = [];
        props.lines = [];
        const graph = new Graph();
        map.forEach((point, index) => {
          graph.addVertex(index);
        });
        if(type === 'basic') {
          map.slice(0, map.length - 1).forEach((point, index) => {
            graph.addEdge(index, (index + 1));
          });
        }
        if(type === 'graph') {
          map.slice(0, map.length - 1).forEach((source, sourceIndex, points) => {
            graph.addEdge(sourceIndex, (sourceIndex + 1));
            map.slice(sourceIndex + 2).filter(destination => (calcHypotenuse((Math.abs(destination.x - source.x)), (Math.abs(destination.y - source.y))) <= 4)).forEach((destination, destinationIndex) => {
              graph.addEdge(sourceIndex, (sourceIndex + 2 + destinationIndex));
            });
          });
        }
        if(type === 'short') {
          map.slice(0, map.length - 1).forEach((source, sourceIndex, points) => {
            graph.addEdge(sourceIndex, (sourceIndex + 1), calcHypotenuse((Math.abs(map[(sourceIndex + 1)].x - map[sourceIndex].x)), (Math.abs(map[(sourceIndex + 1)].y - map[sourceIndex].y))));
            map.slice(sourceIndex + 2).filter(destination => (calcHypotenuse((Math.abs(destination.x - source.x)), (Math.abs(destination.y - source.y))) <= 4)).forEach((destination, destinationIndex) => {
              graph.addEdge(sourceIndex, (sourceIndex + 2 + destinationIndex), calcHypotenuse((Math.abs(map[(sourceIndex + 2 + destinationIndex)].x - map[sourceIndex].x)), (Math.abs(map[(sourceIndex + 2 + destinationIndex)].y - map[sourceIndex].y))));
            });
          });
        }
        const adjacencyList = graph.getAdjacencyList();
        if(type === 'basic') {
          for (const key in adjacencyList) {
            props.points.push(map[key]);
            if (adjacencyList.hasOwnProperty(key)) {
              adjacencyList[key].forEach(item => {
                props.lines.push({startPoint: map[key], endPoint: map[item.vertex]});
              });
            }
          }
        }
        if(type === 'graph') {
          for (const key in adjacencyList) {
            props.points.push(map[key]);
            if (adjacencyList.hasOwnProperty(key)) {
              adjacencyList[key].forEach(item => {
                props.lines.push({startPoint: map[key], endPoint: map[item.vertex]});
              });
            }
          }
        }
        if(type === 'short') {
          function getRoute(source, destination, route) {
            route.push(map[source]);
            if(source === destination) return route;
            const points = adjacencyList[source].map(item => item.vertex);
            return points.length ? getRoute(points[(points.length - 1)], destination, route) : false;
          }
          getRoute(0, (map.length - 1), []).forEach(point => {
            props.points.push(point);
          });
          props.points.slice(0, props.points.length - 1).forEach((point, index) => {
            props.lines.push({startPoint: point, endPoint: props.points[(index + 1)]});
          });
        }
        return new Canvas(props);
      }

      const maps = [EKF_Output4, EKF_Output5, EKF_Output6].map(source => (source.split('\n').map(line => ({x: parseFloat(line.split(',')[line.split(',').length - 1]), y: parseFloat(line.split(',')[line.split(',').length - 2])})).filter(point => point.x && point.y)));
      let canvases = [];
      (map => {
        canvases.push(generateCanvas('basic', [...document.querySelectorAll('.component--canvas')][0], map));
        canvases.push(generateCanvas('graph', [...document.querySelectorAll('.component--canvas')][1], map));
        canvases.push(generateCanvas('short', [...document.querySelectorAll('.component--canvas')][2], map));
      })(maps[1]);
      canvases.forEach(canvase => canvase.draw());
      window.addEventListener('resize', event => {
        canvases.forEach(canvase => canvase.erase());
        canvases.forEach(canvase => canvase.draw());
      });
    </script>
    <script>
      performanceSteps[performanceSteps.length] = performance.now();
      console.log("Call to doSomething took " + (Math.max(...performanceSteps) - Math.min(...performanceSteps)) + " milliseconds.");
    </script>
  </body>
</html>